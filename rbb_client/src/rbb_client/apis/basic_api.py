# coding: utf-8

"""
BasicApi.py
Copyright 2016 SmartBear Software

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

from __future__ import absolute_import

import sys
import os

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class BasicApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def authorize_step_get(self, store_name, step, **kwargs):
        """
        Authorization step forwarded to storage plugin
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.authorize_step_get(store_name, step, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str step: Step of the authorization procedure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'step']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize_step_get" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `authorize_step_get`")
        # verify the required parameter 'step' is set
        if ('step' not in params) or (params['step'] is None):
            raise ValueError("Missing the required parameter `step` when calling `authorize_step_get`")

        resource_path = '/file-storage/{store_name}/authorize/{step}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'step' in params:
            path_params['step'] = params['step']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def authorize_step_post(self, store_name, step, **kwargs):
        """
        Authorization step forwarded to storage plugin
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.authorize_step_post(store_name, step, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str step: Step of the authorization procedure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'step']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize_step_post" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `authorize_step_post`")
        # verify the required parameter 'step' is set
        if ('step' not in params) or (params['step'] is None):
            raise ValueError("Missing the required parameter `step` when calling `authorize_step_post`")

        resource_path = '/file-storage/{store_name}/authorize/{step}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'step' in params:
            path_params['step'] = params['step']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def bag_store_authorize_step_get(self, store_name, step, **kwargs):
        """
        Authorization step forwarded to storage plugin
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.bag_store_authorize_step_get(store_name, step, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str step: Step of the authorization procedure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'step']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bag_store_authorize_step_get" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `bag_store_authorize_step_get`")
        # verify the required parameter 'step' is set
        if ('step' not in params) or (params['step'] is None):
            raise ValueError("Missing the required parameter `step` when calling `bag_store_authorize_step_get`")

        resource_path = '/stores/{store_name}/authorize/{step}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'step' in params:
            path_params['step'] = params['step']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def bag_store_authorize_step_post(self, store_name, step, **kwargs):
        """
        Authorization step forwarded to storage plugin
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.bag_store_authorize_step_post(store_name, step, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str step: Step of the authorization procedure (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'step']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bag_store_authorize_step_post" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `bag_store_authorize_step_post`")
        # verify the required parameter 'step' is set
        if ('step' not in params) or (params['step'] is None):
            raise ValueError("Missing the required parameter `step` when calling `bag_store_authorize_step_post`")

        resource_path = '/stores/{store_name}/authorize/{step}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'step' in params:
            path_params['step'] = params['step']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_bag_comment(self, store_name, bag_name, comment_id, **kwargs):
        """
        Delete a comment
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_bag_comment(store_name, bag_name, comment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :param int comment_id: Comment identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name', 'comment_id']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_bag_comment" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `delete_bag_comment`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `delete_bag_comment`")
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in params) or (params['comment_id'] is None):
            raise ValueError("Missing the required parameter `comment_id` when calling `delete_bag_comment`")

        resource_path = '/stores/{store_name}/bags/{bag_name}/comments/{comment_id}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']
        if 'comment_id' in params:
            path_params['comment_id'] = params['comment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_extraction_configuration(self, config_name, **kwargs):
        """
        Delete extraction configuration
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_extraction_configuration(config_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str config_name: Name of the configuration (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['config_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_extraction_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'config_name' is set
        if ('config_name' not in params) or (params['config_name'] is None):
            raise ValueError("Missing the required parameter `config_name` when calling `delete_extraction_configuration`")

        resource_path = '/extraction/configs/{config_name}'.replace('{format}', 'json')
        path_params = {}
        if 'config_name' in params:
            path_params['config_name'] = params['config_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_file_store(self, store_name, **kwargs):
        """
        Delete file store
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_file_store(store_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file_store" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `delete_file_store`")

        resource_path = '/file-storage/{store_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_session(self, session_id, **kwargs):
        """
        Delete a session or sessions
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_session(session_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str session_id: Session id or all or current (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['session_id']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_session" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'session_id' is set
        if ('session_id' not in params) or (params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `delete_session`")

        resource_path = '/sessions/{session_id}'.replace('{format}', 'json')
        path_params = {}
        if 'session_id' in params:
            path_params['session_id'] = params['session_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_simulation(self, sim_identifier, **kwargs):
        """
        Delete simulation
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_simulation(sim_identifier, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int sim_identifier:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sim_identifier']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_simulation" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'sim_identifier' is set
        if ('sim_identifier' not in params) or (params['sim_identifier'] is None):
            raise ValueError("Missing the required parameter `sim_identifier` when calling `delete_simulation`")

        resource_path = '/simulations/{sim_identifier}'.replace('{format}', 'json')
        path_params = {}
        if 'sim_identifier' in params:
            path_params['sim_identifier'] = params['sim_identifier']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_simulation_environment(self, env_name, **kwargs):
        """
        Delete simulation
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_simulation_environment(env_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str env_name: Name of the simulation environment (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['env_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_simulation_environment" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'env_name' is set
        if ('env_name' not in params) or (params['env_name'] is None):
            raise ValueError("Missing the required parameter `env_name` when calling `delete_simulation_environment`")

        resource_path = '/simulation-environments/{env_name}'.replace('{format}', 'json')
        path_params = {}
        if 'env_name' in params:
            path_params['env_name'] = params['env_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_store(self, store_name, **kwargs):
        """
        Delete file store
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_store(store_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_store" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `delete_store`")

        resource_path = '/stores/{store_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_user_account(self, alias, **kwargs):
        """
        Delete user account
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_user_account(alias, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str alias: Alias of the user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alias']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_account" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'alias' is set
        if ('alias' not in params) or (params['alias'] is None):
            raise ValueError("Missing the required parameter `alias` when calling `delete_user_account`")

        resource_path = '/users/account/{alias}'.replace('{format}', 'json')
        path_params = {}
        if 'alias' in params:
            path_params['alias'] = params['alias']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def dequeue_task(self, worker_name, tasks, labels, **kwargs):
        """
        Take a task from the queue
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.dequeue_task(worker_name, tasks, labels, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str worker_name: Name of the worker trying to acquire a task (required)
        :param str tasks: Tasks that the worker can do (any or a list of tasks) (required)
        :param str labels: Labels the worker wants to do (required)
        :return: TaskDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['worker_name', 'tasks', 'labels']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dequeue_task" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'worker_name' is set
        if ('worker_name' not in params) or (params['worker_name'] is None):
            raise ValueError("Missing the required parameter `worker_name` when calling `dequeue_task`")
        # verify the required parameter 'tasks' is set
        if ('tasks' not in params) or (params['tasks'] is None):
            raise ValueError("Missing the required parameter `tasks` when calling `dequeue_task`")
        # verify the required parameter 'labels' is set
        if ('labels' not in params) or (params['labels'] is None):
            raise ValueError("Missing the required parameter `labels` when calling `dequeue_task`")

        resource_path = '/queue/dequeue'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'worker_name' in params:
            query_params['worker_name'] = params['worker_name']
        if 'tasks' in params:
            query_params['tasks'] = params['tasks']
        if 'labels' in params:
            query_params['labels'] = params['labels']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TaskDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def do_task_action(self, task_identifier, action, **kwargs):
        """
        Perform an action on the task
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.do_task_action(task_identifier, action, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str task_identifier:  (required)
        :param str action: Action to perform (cancel/prio_up) (required)
        :param TaskDetailed task: The task, required depending on the action
        :return: TaskDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_identifier', 'action', 'task']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method do_task_action" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'task_identifier' is set
        if ('task_identifier' not in params) or (params['task_identifier'] is None):
            raise ValueError("Missing the required parameter `task_identifier` when calling `do_task_action`")
        # verify the required parameter 'action' is set
        if ('action' not in params) or (params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `do_task_action`")

        resource_path = '/queue/{task_identifier}'.replace('{format}', 'json')
        path_params = {}
        if 'task_identifier' in params:
            path_params['task_identifier'] = params['task_identifier']

        query_params = {}
        if 'action' in params:
            query_params['action'] = params['action']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task' in params:
            body_params = params['task']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TaskDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_bag_comments(self, store_name, bag_name, **kwargs):
        """
        List comments from bag
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bag_comments(store_name, bag_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :return: list[Comment]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bag_comments" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_bag_comments`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `get_bag_comments`")

        resource_path = '/stores/{store_name}/bags/{bag_name}/comments'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Comment]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_bag_file(self, store_name, bag_name, **kwargs):
        """
        Get rosbag
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bag_file(store_name, bag_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bag_file" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_bag_file`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `get_bag_file`")

        resource_path = '/stores/{store_name}/bags/{bag_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_bag_meta(self, store_name, bag_name, **kwargs):
        """
        List products from bag
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bag_meta(store_name, bag_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :return: BagDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bag_meta" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_bag_meta`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `get_bag_meta`")

        resource_path = '/stores/{store_name}/bags/{bag_name}/meta'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BagDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_bag_tags(self, store_name, bag_name, **kwargs):
        """
        List tag from bag
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bag_tags(store_name, bag_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bag_tags" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_bag_tags`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `get_bag_tags`")

        resource_path = '/stores/{store_name}/bags/{bag_name}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Tag]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_configuration_key(self, config_key, **kwargs):
        """
        Get configuration key
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_configuration_key(config_key, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str config_key: Configuration keys to read, * is all (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['config_key']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_configuration_key" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'config_key' is set
        if ('config_key' not in params) or (params['config_key'] is None):
            raise ValueError("Missing the required parameter `config_key` when calling `get_configuration_key`")

        resource_path = '/configuration/{config_key}'.replace('{format}', 'json')
        path_params = {}
        if 'config_key' in params:
            path_params['config_key'] = params['config_key']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='object',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_cron_endpoint(self, **kwargs):
        """
        Endpoint that should be periodically triggered
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_cron_endpoint(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str jobs: Specific cron jobs to trigger
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobs']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cron_endpoint" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/cron'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'jobs' in params:
            query_params['jobs'] = params['jobs']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_current_user(self, **kwargs):
        """
        Get current user information
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_current_user(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_user" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/users/me'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_extraction_config(self, config_name, **kwargs):
        """
        Get configuration details
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_extraction_config(config_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str config_name: Name of the configuration (required)
        :return: BagExtractionConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['config_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_extraction_config" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'config_name' is set
        if ('config_name' not in params) or (params['config_name'] is None):
            raise ValueError("Missing the required parameter `config_name` when calling `get_extraction_config`")

        resource_path = '/extraction/configs/{config_name}'.replace('{format}', 'json')
        path_params = {}
        if 'config_name' in params:
            path_params['config_name'] = params['config_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BagExtractionConfiguration',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_file(self, store_name, uid, file_name, **kwargs):
        """
        Get file
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file(store_name, uid, file_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param int uid: Unique identifier of the file (required)
        :param str file_name: Name of the file (required)
        :param bool no_redirect: 
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'uid', 'file_name', 'no_redirect']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_file`")
        # verify the required parameter 'uid' is set
        if ('uid' not in params) or (params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `get_file`")
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params) or (params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `get_file`")

        resource_path = '/file-storage/{store_name}/{uid}/{file_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'uid' in params:
            path_params['uid'] = params['uid']
        if 'file_name' in params:
            path_params['file_name'] = params['file_name']

        query_params = {}
        if 'no_redirect' in params:
            query_params['no_redirect'] = params['no_redirect']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_file_meta(self, store_name, uid, file_name, **kwargs):
        """
        Get file meta data
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file_meta(store_name, uid, file_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param int uid: Unique identifier of the file (required)
        :param str file_name: Name of the file (required)
        :return: FileDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'uid', 'file_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_meta" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_file_meta`")
        # verify the required parameter 'uid' is set
        if ('uid' not in params) or (params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `get_file_meta`")
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params) or (params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `get_file_meta`")

        resource_path = '/file-storage/{store_name}/{uid}/{file_name}/meta'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'uid' in params:
            path_params['uid'] = params['uid']
        if 'file_name' in params:
            path_params['file_name'] = params['file_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='FileDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_file_store(self, store_name, **kwargs):
        """
        Get store details
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_file_store(store_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :return: FileStore
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_store" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_file_store`")

        resource_path = '/file-storage/{store_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='FileStore',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_simulation(self, sim_identifier, **kwargs):
        """
        Get simulation
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_simulation(sim_identifier, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int sim_identifier:  (required)
        :param bool expand: 
        :return: SimulationDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sim_identifier', 'expand']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_simulation" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'sim_identifier' is set
        if ('sim_identifier' not in params) or (params['sim_identifier'] is None):
            raise ValueError("Missing the required parameter `sim_identifier` when calling `get_simulation`")

        resource_path = '/simulations/{sim_identifier}'.replace('{format}', 'json')
        path_params = {}
        if 'sim_identifier' in params:
            path_params['sim_identifier'] = params['sim_identifier']

        query_params = {}
        if 'expand' in params:
            query_params['expand'] = params['expand']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SimulationDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_simulation_environment(self, env_name, **kwargs):
        """
        Get simulation environment
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_simulation_environment(env_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str env_name: Name of the simulation environment (required)
        :return: SimulationEnvironmentDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['env_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_simulation_environment" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'env_name' is set
        if ('env_name' not in params) or (params['env_name'] is None):
            raise ValueError("Missing the required parameter `env_name` when calling `get_simulation_environment`")

        resource_path = '/simulation-environments/{env_name}'.replace('{format}', 'json')
        path_params = {}
        if 'env_name' in params:
            path_params['env_name'] = params['env_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SimulationEnvironmentDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_simulation_run(self, sim_identifier, run_identifier, **kwargs):
        """
        Get simulation run
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_simulation_run(sim_identifier, run_identifier, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int sim_identifier:  (required)
        :param int run_identifier:  (required)
        :param bool expand: 
        :return: SimulationRunDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sim_identifier', 'run_identifier', 'expand']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_simulation_run" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'sim_identifier' is set
        if ('sim_identifier' not in params) or (params['sim_identifier'] is None):
            raise ValueError("Missing the required parameter `sim_identifier` when calling `get_simulation_run`")
        # verify the required parameter 'run_identifier' is set
        if ('run_identifier' not in params) or (params['run_identifier'] is None):
            raise ValueError("Missing the required parameter `run_identifier` when calling `get_simulation_run`")

        resource_path = '/simulations/{sim_identifier}/runs/{run_identifier}'.replace('{format}', 'json')
        path_params = {}
        if 'sim_identifier' in params:
            path_params['sim_identifier'] = params['sim_identifier']
        if 'run_identifier' in params:
            path_params['run_identifier'] = params['run_identifier']

        query_params = {}
        if 'expand' in params:
            query_params['expand'] = params['expand']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SimulationRunDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_store(self, store_name, **kwargs):
        """
        Get store details
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_store(store_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :return: BagStoreDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_store" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_store`")

        resource_path = '/stores/{store_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BagStoreDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_store_extraction_configs(self, store_name, **kwargs):
        """
        Get list of auto extraction configs
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_store_extraction_configs(store_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :return: list[BagExtractionConfiguration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_store_extraction_configs" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `get_store_extraction_configs`")

        resource_path = '/stores/{store_name}/auto-extraction-configs'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BagExtractionConfiguration]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_tag(self, tag, **kwargs):
        """
        Get tag info
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_tag(tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str tag: Name of the tag (required)
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tag" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `get_tag`")

        resource_path = '/tags/{tag}'.replace('{format}', 'json')
        path_params = {}
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Tag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_task(self, task_identifier, **kwargs):
        """
        Take a task from the queue
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_task(task_identifier, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str task_identifier:  (required)
        :return: TaskDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_identifier']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'task_identifier' is set
        if ('task_identifier' not in params) or (params['task_identifier'] is None):
            raise ValueError("Missing the required parameter `task_identifier` when calling `get_task`")

        resource_path = '/queue/{task_identifier}'.replace('{format}', 'json')
        path_params = {}
        if 'task_identifier' in params:
            path_params['task_identifier'] = params['task_identifier']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TaskDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def get_user_account(self, alias, **kwargs):
        """
        Get user information
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_account(alias, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str alias: Alias of the user (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alias']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_account" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'alias' is set
        if ('alias' not in params) or (params['alias'] is None):
            raise ValueError("Missing the required parameter `alias` when calling `get_user_account`")

        resource_path = '/users/account/{alias}'.replace('{format}', 'json')
        path_params = {}
        if 'alias' in params:
            path_params['alias'] = params['alias']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_bags(self, store_name, **kwargs):
        """
        List bags in store
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_bags(store_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param int limit: 
        :param int offset: 
        :param str ordering: 
        :param datetime discovered_gte: 
        :param datetime discovered_lte: 
        :param datetime start_time_gte: 
        :param datetime start_time_lte: 
        :param datetime end_time_gte: 
        :param datetime end_time_lte: 
        :param float duration_gte: 
        :param float duration_lte: 
        :param bool meta_available: 
        :param bool is_extracted: 
        :param str name: 
        :param str tags: 
        :param bool in_trash: 
        :return: list[BagSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'limit', 'offset', 'ordering', 'discovered_gte', 'discovered_lte', 'start_time_gte', 'start_time_lte', 'end_time_gte', 'end_time_lte', 'duration_gte', 'duration_lte', 'meta_available', 'is_extracted', 'name', 'tags', 'in_trash']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_bags" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `list_bags`")

        resource_path = '/stores/{store_name}/bags'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'ordering' in params:
            query_params['ordering'] = params['ordering']
        if 'discovered_gte' in params:
            query_params['discovered_gte'] = params['discovered_gte']
        if 'discovered_lte' in params:
            query_params['discovered_lte'] = params['discovered_lte']
        if 'start_time_gte' in params:
            query_params['start_time_gte'] = params['start_time_gte']
        if 'start_time_lte' in params:
            query_params['start_time_lte'] = params['start_time_lte']
        if 'end_time_gte' in params:
            query_params['end_time_gte'] = params['end_time_gte']
        if 'end_time_lte' in params:
            query_params['end_time_lte'] = params['end_time_lte']
        if 'duration_gte' in params:
            query_params['duration_gte'] = params['duration_gte']
        if 'duration_lte' in params:
            query_params['duration_lte'] = params['duration_lte']
        if 'meta_available' in params:
            query_params['meta_available'] = params['meta_available']
        if 'is_extracted' in params:
            query_params['is_extracted'] = params['is_extracted']
        if 'name' in params:
            query_params['name'] = params['name']
        if 'tags' in params:
            query_params['tags'] = params['tags']
        if 'in_trash' in params:
            query_params['in_trash'] = params['in_trash']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BagSummary]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_extraction_configurations(self, **kwargs):
        """
        List available configurations
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_extraction_configurations(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[BagExtractionConfiguration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_extraction_configurations" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/extraction/configs'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BagExtractionConfiguration]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_file_stores(self, **kwargs):
        """
        List available file stores
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_file_stores(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[FileStore]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_file_stores" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/file-storage'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[FileStore]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_queue(self, **kwargs):
        """
        List task queue
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_queue(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int limit: 
        :param int offset: 
        :param str ordering: 
        :param str running: Include running tasks, default is true
        :param str finished: Include finished tasks, default is true
        :param str queued: Include queued tasks, default is true
        :return: list[TaskSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'offset', 'ordering', 'running', 'finished', 'queued']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_queue" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/queue'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'ordering' in params:
            query_params['ordering'] = params['ordering']
        if 'running' in params:
            query_params['running'] = params['running']
        if 'finished' in params:
            query_params['finished'] = params['finished']
        if 'queued' in params:
            query_params['queued'] = params['queued']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[TaskSummary]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_sessions(self, **kwargs):
        """
        List current session
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_sessions(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[Session]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_sessions" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/sessions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Session]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_simulation_environments(self, **kwargs):
        """
        List available simulation environments
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_simulation_environments(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[SimulationEnvironmentSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_simulation_environments" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/simulation-environments'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[SimulationEnvironmentSummary]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_simulation_runs(self, sim_identifier, **kwargs):
        """
        List simulation runs
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_simulation_runs(sim_identifier, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int sim_identifier:  (required)
        :return: list[SimulationRunSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sim_identifier']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_simulation_runs" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'sim_identifier' is set
        if ('sim_identifier' not in params) or (params['sim_identifier'] is None):
            raise ValueError("Missing the required parameter `sim_identifier` when calling `list_simulation_runs`")

        resource_path = '/simulations/{sim_identifier}/runs'.replace('{format}', 'json')
        path_params = {}
        if 'sim_identifier' in params:
            path_params['sim_identifier'] = params['sim_identifier']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[SimulationRunSummary]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_simulations(self, **kwargs):
        """
        List simulations
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_simulations(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int limit: 
        :param int offset: 
        :param str ordering: 
        :return: list[SimulationSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'offset', 'ordering']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_simulations" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/simulations'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'ordering' in params:
            query_params['ordering'] = params['ordering']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[SimulationSummary]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_stores(self, **kwargs):
        """
        List available stores
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_stores(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[BagStoreDetailed]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_stores" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/stores'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BagStoreDetailed]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_tags(self, **kwargs):
        """
        List all tags
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_tags(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_tags" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/tags'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Tag]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def list_user_accounts(self, **kwargs):
        """
        List user acounts
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_user_accounts(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_accounts" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/users/account'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[User]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def new_bag_comment(self, store_name, bag_name, comment, **kwargs):
        """
        New bag comment
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.new_bag_comment(store_name, bag_name, comment, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :param Comment comment: Comment (required)
        :return: Comment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name', 'comment']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method new_bag_comment" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `new_bag_comment`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `new_bag_comment`")
        # verify the required parameter 'comment' is set
        if ('comment' not in params) or (params['comment'] is None):
            raise ValueError("Missing the required parameter `comment` when calling `new_bag_comment`")

        resource_path = '/stores/{store_name}/bags/{bag_name}/comments'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'comment' in params:
            body_params = params['comment']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Comment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def new_file(self, store_name, file, **kwargs):
        """
        Register new file
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.new_file(store_name, file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param FileDetailed file: The file metadata (required)
        :return: FileDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'file']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method new_file" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `new_file`")
        # verify the required parameter 'file' is set
        if ('file' not in params) or (params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `new_file`")

        resource_path = '/file-storage/{store_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'file' in params:
            body_params = params['file']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='FileDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def new_session(self, **kwargs):
        """
        Create a new session
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.new_session(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int valid_for: Validity in seconds
        :return: Session
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['valid_for']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method new_session" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/sessions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'valid_for' in params:
            query_params['valid_for'] = params['valid_for']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Session',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def new_simulation(self, simulation, **kwargs):
        """
        New simulation
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.new_simulation(simulation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param SimulationDetailed simulation: Simulation (required)
        :param str trigger: Hooks to trigger
        :return: SimulationDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['simulation', 'trigger']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method new_simulation" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'simulation' is set
        if ('simulation' not in params) or (params['simulation'] is None):
            raise ValueError("Missing the required parameter `simulation` when calling `new_simulation`")

        resource_path = '/simulations'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'trigger' in params:
            query_params['trigger'] = params['trigger']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'simulation' in params:
            body_params = params['simulation']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SimulationDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def new_simulation_run(self, sim_identifier, simulation_run, **kwargs):
        """
        New simulation run
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.new_simulation_run(sim_identifier, simulation_run, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int sim_identifier:  (required)
        :param SimulationRunDetailed simulation_run: Simulation run (required)
        :return: SimulationRunDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sim_identifier', 'simulation_run']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method new_simulation_run" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'sim_identifier' is set
        if ('sim_identifier' not in params) or (params['sim_identifier'] is None):
            raise ValueError("Missing the required parameter `sim_identifier` when calling `new_simulation_run`")
        # verify the required parameter 'simulation_run' is set
        if ('simulation_run' not in params) or (params['simulation_run'] is None):
            raise ValueError("Missing the required parameter `simulation_run` when calling `new_simulation_run`")

        resource_path = '/simulations/{sim_identifier}/runs'.replace('{format}', 'json')
        path_params = {}
        if 'sim_identifier' in params:
            path_params['sim_identifier'] = params['sim_identifier']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'simulation_run' in params:
            body_params = params['simulation_run']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SimulationRunDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def new_task(self, task, **kwargs):
        """
        Create a new task
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.new_task(task, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param TaskDetailed task: The task (required)
        :return: TaskDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method new_task" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'task' is set
        if ('task' not in params) or (params['task'] is None):
            raise ValueError("Missing the required parameter `task` when calling `new_task`")

        resource_path = '/queue'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task' in params:
            body_params = params['task']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TaskDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def patch_bag_meta(self, store_name, bag_name, bag, **kwargs):
        """
        Partial update of bag information (this only supports a few fields)
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_bag_meta(store_name, bag_name, bag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :param object bag: Bag to register (required)
        :param str trigger: Hooks to trigger
        :return: BagDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name', 'bag', 'trigger']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_bag_meta" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `patch_bag_meta`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `patch_bag_meta`")
        # verify the required parameter 'bag' is set
        if ('bag' not in params) or (params['bag'] is None):
            raise ValueError("Missing the required parameter `bag` when calling `patch_bag_meta`")

        resource_path = '/stores/{store_name}/bags/{bag_name}/meta'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']

        query_params = {}
        if 'trigger' in params:
            query_params['trigger'] = params['trigger']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bag' in params:
            body_params = params['bag']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BagDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def patch_task(self, task_identifier, task, **kwargs):
        """
        Partial update of task (this only supports a few fields)
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_task(task_identifier, task, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str task_identifier:  (required)
        :param object task: Fields to update (required)
        :return: TaskDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_identifier', 'task']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_task" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'task_identifier' is set
        if ('task_identifier' not in params) or (params['task_identifier'] is None):
            raise ValueError("Missing the required parameter `task_identifier` when calling `patch_task`")
        # verify the required parameter 'task' is set
        if ('task' not in params) or (params['task'] is None):
            raise ValueError("Missing the required parameter `task` when calling `patch_task`")

        resource_path = '/queue/{task_identifier}'.replace('{format}', 'json')
        path_params = {}
        if 'task_identifier' in params:
            path_params['task_identifier'] = params['task_identifier']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task' in params:
            body_params = params['task']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TaskDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_bag_meta(self, store_name, bag_name, bag, **kwargs):
        """
        Create/update bag information
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_bag_meta(store_name, bag_name, bag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :param BagDetailed bag: Bag to register (required)
        :param str trigger: Hooks to trigger
        :return: BagDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name', 'bag', 'trigger']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_bag_meta" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `put_bag_meta`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `put_bag_meta`")
        # verify the required parameter 'bag' is set
        if ('bag' not in params) or (params['bag'] is None):
            raise ValueError("Missing the required parameter `bag` when calling `put_bag_meta`")

        resource_path = '/stores/{store_name}/bags/{bag_name}/meta'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']

        query_params = {}
        if 'trigger' in params:
            query_params['trigger'] = params['trigger']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bag' in params:
            body_params = params['bag']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BagDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_bag_tags(self, store_name, bag_name, tags, **kwargs):
        """
        Change bag tags
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_bag_tags(store_name, bag_name, tags, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param str bag_name: Name of the bag (required)
        :param list[str] tags: List of tags (required)
        :param bool auto_create: Create non existing tags
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'bag_name', 'tags', 'auto_create']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_bag_tags" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `put_bag_tags`")
        # verify the required parameter 'bag_name' is set
        if ('bag_name' not in params) or (params['bag_name'] is None):
            raise ValueError("Missing the required parameter `bag_name` when calling `put_bag_tags`")
        # verify the required parameter 'tags' is set
        if ('tags' not in params) or (params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `put_bag_tags`")

        resource_path = '/stores/{store_name}/bags/{bag_name}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']
        if 'bag_name' in params:
            path_params['bag_name'] = params['bag_name']

        query_params = {}
        if 'auto_create' in params:
            query_params['auto_create'] = params['auto_create']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tags' in params:
            body_params = params['tags']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Tag]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_configuration_key(self, config_key, config_value, **kwargs):
        """
        Write configuration key
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_configuration_key(config_key, config_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str config_key: Configuration key to read (required)
        :param object config_value: Configuration keys (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['config_key', 'config_value']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_configuration_key" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'config_key' is set
        if ('config_key' not in params) or (params['config_key'] is None):
            raise ValueError("Missing the required parameter `config_key` when calling `put_configuration_key`")
        # verify the required parameter 'config_value' is set
        if ('config_value' not in params) or (params['config_value'] is None):
            raise ValueError("Missing the required parameter `config_value` when calling `put_configuration_key`")

        resource_path = '/configuration/{config_key}'.replace('{format}', 'json')
        path_params = {}
        if 'config_key' in params:
            path_params['config_key'] = params['config_key']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'config_value' in params:
            body_params = params['config_value']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_current_user(self, user, **kwargs):
        """
        Change current user information
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_current_user(user, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param User user: The user information (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_current_user" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'user' is set
        if ('user' not in params) or (params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `put_current_user`")

        resource_path = '/users/me'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in params:
            body_params = params['user']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_extraction_configuration(self, config_name, configuration_obj, **kwargs):
        """
        Create/update configuration
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_extraction_configuration(config_name, configuration_obj, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str config_name: Name of the configuration (required)
        :param BagExtractionConfiguration configuration_obj: Configuration information (required)
        :param bool block_on_existing: Only create a new one, block if one already exists
        :return: BagExtractionConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['config_name', 'configuration_obj', 'block_on_existing']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_extraction_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'config_name' is set
        if ('config_name' not in params) or (params['config_name'] is None):
            raise ValueError("Missing the required parameter `config_name` when calling `put_extraction_configuration`")
        # verify the required parameter 'configuration_obj' is set
        if ('configuration_obj' not in params) or (params['configuration_obj'] is None):
            raise ValueError("Missing the required parameter `configuration_obj` when calling `put_extraction_configuration`")

        resource_path = '/extraction/configs/{config_name}'.replace('{format}', 'json')
        path_params = {}
        if 'config_name' in params:
            path_params['config_name'] = params['config_name']

        query_params = {}
        if 'block_on_existing' in params:
            query_params['block_on_existing'] = params['block_on_existing']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configuration_obj' in params:
            body_params = params['configuration_obj']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BagExtractionConfiguration',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_file_store(self, store_name, store, **kwargs):
        """
        Create/update store
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_file_store(store_name, store, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param FileStore store: Store information (required)
        :param bool block_on_existing: Only create a new one, block if one already exists
        :return: FileStore
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'store', 'block_on_existing']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_file_store" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `put_file_store`")
        # verify the required parameter 'store' is set
        if ('store' not in params) or (params['store'] is None):
            raise ValueError("Missing the required parameter `store` when calling `put_file_store`")

        resource_path = '/file-storage/{store_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}
        if 'block_on_existing' in params:
            query_params['block_on_existing'] = params['block_on_existing']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'store' in params:
            body_params = params['store']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='FileStore',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_simulation(self, sim_identifier, simulation, **kwargs):
        """
        Update a simulation
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_simulation(sim_identifier, simulation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int sim_identifier:  (required)
        :param SimulationDetailed simulation: Simulation (required)
        :return: SimulationDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sim_identifier', 'simulation']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_simulation" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'sim_identifier' is set
        if ('sim_identifier' not in params) or (params['sim_identifier'] is None):
            raise ValueError("Missing the required parameter `sim_identifier` when calling `put_simulation`")
        # verify the required parameter 'simulation' is set
        if ('simulation' not in params) or (params['simulation'] is None):
            raise ValueError("Missing the required parameter `simulation` when calling `put_simulation`")

        resource_path = '/simulations/{sim_identifier}'.replace('{format}', 'json')
        path_params = {}
        if 'sim_identifier' in params:
            path_params['sim_identifier'] = params['sim_identifier']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'simulation' in params:
            body_params = params['simulation']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SimulationDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_simulation_environment(self, env_name, environment, **kwargs):
        """
        Create/update a simulation environment
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_simulation_environment(env_name, environment, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str env_name: Name of the simulation environment (required)
        :param SimulationEnvironmentDetailed environment: Simulation environment (required)
        :param bool block_on_existing: Only create a new one, block if one already exists
        :return: SimulationEnvironmentDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['env_name', 'environment', 'block_on_existing']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_simulation_environment" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'env_name' is set
        if ('env_name' not in params) or (params['env_name'] is None):
            raise ValueError("Missing the required parameter `env_name` when calling `put_simulation_environment`")
        # verify the required parameter 'environment' is set
        if ('environment' not in params) or (params['environment'] is None):
            raise ValueError("Missing the required parameter `environment` when calling `put_simulation_environment`")

        resource_path = '/simulation-environments/{env_name}'.replace('{format}', 'json')
        path_params = {}
        if 'env_name' in params:
            path_params['env_name'] = params['env_name']

        query_params = {}
        if 'block_on_existing' in params:
            query_params['block_on_existing'] = params['block_on_existing']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'environment' in params:
            body_params = params['environment']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SimulationEnvironmentDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_store(self, store_name, store, **kwargs):
        """
        Create/update store
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_store(store_name, store, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param BagStoreDetailed store: Store information (required)
        :param bool block_on_existing: Only create a new one, block if one already exists
        :return: BagStoreDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'store', 'block_on_existing']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_store" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `put_store`")
        # verify the required parameter 'store' is set
        if ('store' not in params) or (params['store'] is None):
            raise ValueError("Missing the required parameter `store` when calling `put_store`")

        resource_path = '/stores/{store_name}'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}
        if 'block_on_existing' in params:
            query_params['block_on_existing'] = params['block_on_existing']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'store' in params:
            body_params = params['store']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BagStoreDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_store_extraction_configs(self, store_name, config_list, **kwargs):
        """
        Create/update store
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_store_extraction_configs(store_name, config_list, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str store_name: Name of the store (required)
        :param list[str] config_list: List of config names (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'config_list']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_store_extraction_configs" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'store_name' is set
        if ('store_name' not in params) or (params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `put_store_extraction_configs`")
        # verify the required parameter 'config_list' is set
        if ('config_list' not in params) or (params['config_list'] is None):
            raise ValueError("Missing the required parameter `config_list` when calling `put_store_extraction_configs`")

        resource_path = '/stores/{store_name}/auto-extraction-configs'.replace('{format}', 'json')
        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'config_list' in params:
            body_params = params['config_list']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[str]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_tag(self, tag, tag_obj, **kwargs):
        """
        Create/update tag
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_tag(tag, tag_obj, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str tag: Name of the tag (required)
        :param Tag tag_obj: Tag information (required)
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag', 'tag_obj']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_tag" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `put_tag`")
        # verify the required parameter 'tag_obj' is set
        if ('tag_obj' not in params) or (params['tag_obj'] is None):
            raise ValueError("Missing the required parameter `tag_obj` when calling `put_tag`")

        resource_path = '/tags/{tag}'.replace('{format}', 'json')
        path_params = {}
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tag_obj' in params:
            body_params = params['tag_obj']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Tag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_task(self, task_identifier, task, **kwargs):
        """
        Update a task
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_task(task_identifier, task, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str task_identifier:  (required)
        :param TaskDetailed task: The task (required)
        :return: TaskDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_identifier', 'task']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_task" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'task_identifier' is set
        if ('task_identifier' not in params) or (params['task_identifier'] is None):
            raise ValueError("Missing the required parameter `task_identifier` when calling `put_task`")
        # verify the required parameter 'task' is set
        if ('task' not in params) or (params['task'] is None):
            raise ValueError("Missing the required parameter `task` when calling `put_task`")

        resource_path = '/queue/{task_identifier}'.replace('{format}', 'json')
        path_params = {}
        if 'task_identifier' in params:
            path_params['task_identifier'] = params['task_identifier']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task' in params:
            body_params = params['task']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TaskDetailed',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def put_user_account(self, alias, user, **kwargs):
        """
        Change user information
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_user_account(alias, user, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str alias: Alias of the user (required)
        :param User user: The user information (required)
        :param bool block_on_existing: Only create a new one, block if one already exists
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alias', 'user', 'block_on_existing']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_user_account" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'alias' is set
        if ('alias' not in params) or (params['alias'] is None):
            raise ValueError("Missing the required parameter `alias` when calling `put_user_account`")
        # verify the required parameter 'user' is set
        if ('user' not in params) or (params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `put_user_account`")

        resource_path = '/users/account/{alias}'.replace('{format}', 'json')
        path_params = {}
        if 'alias' in params:
            path_params['alias'] = params['alias']

        query_params = {}
        if 'block_on_existing' in params:
            query_params['block_on_existing'] = params['block_on_existing']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in params:
            body_params = params['user']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['basicAuth']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='User',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response
